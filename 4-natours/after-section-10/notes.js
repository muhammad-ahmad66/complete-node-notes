/*
 * SECTION 11
 * MODELLING DATA AND ADVANCED MONGOOSE
 *
 * SECTION INTRO:
 * Knowing how to work with data is one of the most important and valuable skills tha we can have as a backend developer. That's why in this section we're gonna dive really deep into data modeling concepts and techniques. By the end of this section our API will be fully functioning with all routes and all resources, a complete authentication and authorization, and also all established relationships between all the data sets.
 */

/*
* lecture 147
* MongoDB Data Modeling 

! for this lecture must read pdf file as well. 
One of the most important steps in building intensive apps is to actually model all this data in MongoDB. And so that's what we're gonna talk about in this lecture. So, it's really crucial that you follow it through even at first its a lot to take in. 
? What is Data Modeling?
Data modeling is the process of taking unstructured data generated by a real world scenario, and then structured it into a logical data model in a database.  And we do that according to a set of criteria which we're gonna learn about in this video. For example let's say that we want to design an online shop data model. There will be initially a ton of unstructured data that we know we need, stuff like products, categories, customer's orders, shopping carts, suppliers..., Our goal with data modeling is to then structuring this data into a logical way, reflecting the real-world relationships that exists between some of these data sets. SEE PDF FILE.
Data modeling is the most demanding part of building an entire application. Because it really is not always straight forward. So there is not just one unique correct way of structuring the data. 
We're gonna go through four steps. 
1- In first step we learn about how to identify different types of relationships between data. 
2- Then we're gonna understand the difference referencing or normalization and embedding or denormalization. 
3- In the next and most important step; will show my(jonas) framework for deciding whether we should embed documents or reference to other documents based on a couple of difference factors. 
4- Also we've to quickly talk about different types of referencing, because that's important if that is the type of design that we choose for our data. 

? Different types of Relationships that can exist between data. 
There are three big types of relationships. One to One(1:1), One to Many(1:many), Many to Many(many:many).
we'll gonna use a movie application as an example here. 
1:1 Relationships: One filed can only have one value.one movie only ever have one name. 

1:many Relationships: This is the most important relationships, and they are so important that in mongodb we actually distinguish between three types of one to may relationships. one to few, one to many, one to a ton / a million,
example of one to few is that one movie can win many awards, but just a few. 
example of one to many is that one movie can have thousands of reviews.
In general one to many relationships means that one document can relate to many other documents. 

many:many Relationship: one movie can have many actors, and at the same time one actor can play in many movies. so here a relationship goes in both directions while other two goes in only one direction. for example one movie can have many reviews, but one specific review is only for one movie. 

? Referencing VS Embedding
Referencing and Embedding two datasets. 
Each time we've two related datasets we can either represent that related data in a reference or normalized form or in an embedded or denormalized form. 
In a reference form we keep two related datasets and all the documents separated. All the data is nicely separated, which is exactly what normalized means. we would have one movie document and one actor document for each actor. 
? Now how do we then make a connection between movie and the actors so that later in our app we can show which actors played in a particular movie. because a movie has no way of knowing about the actors. 
Well that's where the IDs come in. So, we use the actor IDs in order to create references on the movie document. Effectively connecting movies with actors. 
! SEE PDF FILE
In the movie document we've and array where we stored ids of all the actors, so when we request data about a certain movie we can easily identify its actors. This type of referencing is called child referencing, because its the parent, in this case the move, who referencing its children, in this case the actors.
So we're really creating some sort of hierarchy here. 
Now there is also parent referencing, we talked bout bit later. 
And by the way in relational database; all data is always represented in normalized form. But in NoSQL database like mongoDB, we can denormalize data into a denormalized form simply by embedding the related documents right into the main document. So, now we've all the relevant data about actors right inside the one main movie document without the need for separate documents, collections, and IDs. So, if we choose to denormalize or to embed our data we will have one main document containing all the main data as well as the related data. And the result of this is that our application will need to fewer queries to the database, because we can get all the data about movies and actors all at the same time, which will increase our performance. Now the downside here is of course that we can't really query the embedded data on its own. And so if that's a requirement for the application we would have to choose a normalize design. Since we're talking about pros and cons of the denormalized form, lets do the same about the normalized design. 
Basically normalize form is kind of the opposite of embedded, there is an improvement in performance when we often need to query the related data on its own. because we then can just query the data that we need and not always movies and actors together. But on the other hand when we need to actually query movies and actors together we then are gonna many queries to the database.

? How do we actually decide if we should normalize or denormalize the data? 
When we've two related datasets; we have to decide if we're gonna embed the datasets or if we're gonna keep them separated and reference them from one datasets to the other. We use three criteria to take that decision.
1- First we look at the type of relationships that exist between datasets. 
2- We try to determine the data access pattern of the dataset that we want to either embed or reference. And this just means to analyze how often data is read and written in that dataset. 
3- Data Closeness: Data closeness is term that I(Jonas) actually just made up, but what it means is how much the data is really related, and how we want to query the data from the database. 
Now to take the decision; we need to combine all of these three criteria. 
! SEE PDF - MUST MUST MUST

Now let's say that we have chosen to normalize/reference our datasets. Then after that we still have to choose between three different types of referencing, Child Referencing, Parent Referencing, and Two-Way Referencing. 

- Child referencing: In child referencing we basically keep references to the related child documents in a parent document. and they are usually stored in an array. each document(child) has an id and all the id will store in parent document. The problem is that, this array of ids can become very large if there are lots of children. And this is an anti-pattern in mongodb, something the we should avoid at all costs. Also child referencing makes it so that parents and children are very tightly coupled. 

- Parent referencing: In parent referencing, in each child document we keep a reference to the parent element. The child always knows it's parent, so in this case the parent actually knows nothing about the children. 
The conclusion is that in general child referencing is best used for one to a few relationships. On the other hand parent referencing is best used for one to many and one to a ton relationships. Always keep in mind that one of the most important principle of data modeling is that array should never be grow indefinitely, In order to never break that 16MB limit. (one document must has < 16MB size)

- Two way referencing: We usually use this two way referencing to design many to many relationships. And it works like this, In each movie we will keep references to all the actors that paly in that movie. And at the same time in each actor we also keep references to all the movies that the actor played in. Movies and actors are connected to both directions. 

In general always favor embedding, unless there is good reason nto to embed.
*/

/*
* lecture 148
* Designing Our Data Model

Let's now use that theory in order to actually design the data model of our Natours app. And this the most difficult part of building an app. 

let's star with all the datasets that we actually need in our application, tours, users, these two we already have. Tours and users are two completely separate(normalized) datasets. Next up, we're also gonna have reviews, and we'll also have locations. because most tours actually have a number of different locations. And finally we also gonna have bookings. 
We've all these datasets. Now let's actually model the relationships that exist between them. 
* users, tours, reviews, locations, bookings
? Relationship between users and reviews: 
This relationship is clearly a one-to-many relationship, because one user can write multiple reviews, but one review can only belong to one user. and the parent in this relationship is clearly the users. Anyway, we I choose to model this relationship using parent referencing, and that's because a user can write a lot of reviews and also because we might actually need to query only for the reviews on their own. It's parent referencing, basically the review keeping a reference of the user, so keeping an ID. 

? Relationship between tours and reviews:
Again it's one to many relationship. where one tour can have multiple reviews but one review can only be about one tour. We model it exact same way as users-review relation. So, again parent referencing, and in the end the reviews end up with a tour id and user id. then once we query a review we always know exactly tour, and user of belongs to this review.

? Relationship between tours and location. 
Each tour is gonna have a couple of locations,  and each of location can also be part of another tours. So here few-to-few (many-to-many) relationship. This could be a good example of two-way referencing. so basically normalizing the locations into its own dataset. here but instead we're gonna denormalize the locations, so to embed them into the tours. That's for few reasons; first because there only so few locations. also we will not gonna access the locations on their own. also these locations are intrinsically related to the tours because really without locations there couldn't be any tours. So we embed locations to tours. 

? Relationship between tours and users:
this relationship between is again a few-to-few relationship, because one tour can have only a few users(so a few tour-guides), but at a same time, each tour guide can also be guiding a few tours. Modeling this relationship we could do it in two ways, by referencing or embedding. 

? Bookings: 
Basically a new booking will be created each time that a user purchases a tour. So, this is still kind of a relationship,between users and tours. because it's a user who is gonna buy a tour. But we also want to store some data about the relationship itself, so in this case about the purchase itself in our database, for example the price or the date when the purchase happened or something like that. So in case like this it's a good idea to create an extra dataset, which is in this case bookings. And so, of course there will be a relationship between tours and bookings and also users and bookings. Because the booking connects tours with users but kind of with an intermediate step. So, one tour can have many bookings, but one booking can only belong to one tour, and the same thing with the users. so one user can book many tours, and but one booking can only belong to one of the users. So of course we've a one-to-many relationship in both cases, and also in both cases we're gonna use parent referencing. so that means that on each booking we're gonna keep an id of both the tour that was purchased and also of the user who actually purchased the tour. 

*/
/*
* lecture 149
* Modelling Locations(Geospatial Data)
Now we're finally gonna start implementing our data model, and starting with the locations. So in this video we're gonna learn all bout geospatial data in MongoDB. 
Remember from the previous lecture that our location data will actually be embedded into the tours. And so therefor we're basically gonna declare everything that is related to locations in our tour model. so let's open tourModel file. 


So we'll have startLocation and then also, locations in general. Now mongodb supports geospatial data out of the box. And geospatial data is basically data that describes places on earth using longitude and latitude coordinates. So we can describes simple points, or we can also describe more complex geometries, like lines or even polygons, or even multi-polygons.
lets implement this geospatial data. And mongodb uses a special data format called GeoJSON, in order to specify geospatial data. 
? Now how does this actually work?
startLocation: {

} // This object we specified here is actually, this time not for the schema types options as we have it before. up there like:secretTour: {
      type: Boolean,
      default: false
    }  But now the object is actually really an embedded object. And so inside this object, we can specify a couple of properties. And in order for this object to be recognized as geospatial JSON, we need the type and the coordinates properties, So, we need type and we need coordinates and noe each of these fields(type and coordinates) then gonna get it's own schema type options. so basically here it's a bit nested, we are one level deeper

so we've type schema type options and then we also need schema type options for coordinates. For type the type will be string, and default will be 'Point', we could also specify polygons or lines.. as a default. but this is a standard to put 'Point' as a default. And we also specify the only possible options by defining the enum(enumeration) property. In this case we only want a point.
We need to define type for coordinates too, an array of coordinates. coordinates: [Number], it means that we expects an array of numbers. and this array as the name says is the coordinates of the point with the longitude first and second the latitude, this's a bit counterintuitive(متضاد) because usually it works the other way around, that's how it works in GeoJSON. if we see GoogleMaps, there will be the fist latitude and then the longitude.
Remember the latitude is basically the horizontal position measured in degrees starting from the equator, so equator it's zero degrees and in the north pole it's 90 degrees. And longitude is just the same thing but vertically.
We also want to specify a property for the address as a string and also a description for this start location again as a string.
In order to specify geospatial data with mongodb we basically need to create a new object such as we did here, And that object then needs to have at least two field names coordinates as array of numbers and then the type which should be type of string, may be points, lines, or any other geometries, and we can add some more fields, such as we did here, 
Remember in last lecture we said, we're gonna embed all the locations into the tour documents, but right now this startLocation here is not really a document itself. it's really just an object describing a certain point on the earth. But in order to really create new documents and then embed them into another document we actually need to create an array, So it's actually very similar to what we already have here, but it needs to be an array. so that's what we're gonna do with our locations. so,
location: [
  {
    type: {
      type: String,
      default: 'Point',
      enum: ['Point']
    },
    coordinates: [Number],
    address: String,
    description: String,
    day: Number, // this day will basically be the day of the tour in which people will go to this location. 
  }
]
Now if we wanted to make it simpler, we could delete the startLocation all together, and then simple define the first location as the startLocation and set it to day number zero. But it's nice to also have the startLocation as a separate field. So this is how we create an embedded documents. remember we always need to use array. so by specifying an array of object, this will then create brand new documents, inside of parent document, which is in this case the tour. 
In order to create some locations we're actually going to import all our original data, so instead of creating new tours, we'll delete the ones we have. and then import complete data. in dev-data folder, remember before we imported tours-simple.json file, but we also have tours file and this then actually has locations and the startLocation. In each locations we see each location has it's own id, so these are really are documents. not just simple objects. So lets go to our import-dev-data.js and replace in fs.readFileSync(`${__dirname}/tours.json`, 'utf8'); and them first delete existing tours using --delete and import using --import
$ node ./dev-data/data/import-dev-data.js --delete
     


*/
